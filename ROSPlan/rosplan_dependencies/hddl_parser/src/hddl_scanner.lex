/* 
 * FLEX HDDL scanner, match patterns and generate tokens based on
 * predefined regular expressions, communicate those tokens to BISON grammar
 *
 */

%{ /* -*- C++ -*- */

    /*
     * ============ Prologue
     */

    # include "hddl_parser.h" // provided by user
    # include "hddl_parser.tab.hpp" // automatically generated by bison
%}

/*
 * ============ Bison declarations
 */

%option noyywrap nounput batch debug noinput

/* regular expression to match all letters including digits and hyphens */
strings    [a-zA-Z][a-zA-Z_0-9_-]*

/* regular expression to match all digits */
numbers    [0-9]+

/* regular expression to match blank spaces */
blank [ \t]

/* regular expression to match comments */
comments ;.*

%{
  // Code run each time a pattern is matched.
  # define YY_USER_ACTION  loc.columns (yyleng);
%}


%% /* ============ Grammar rules start */

%{
    // A handy shortcut to the location held by the HDDLParser.
    yy::location& loc = hddl_parser.location_;

    // Code run each time yylex is called.
    loc.step ();
    
    // sadly no comments are allowed in the next section, compiler complains!
%}

{blank}+   loc.step();
[\n]+      loc.lines (yyleng); loc.step();

"define"            return yy::parser::make_DEFINE(yytext, loc);
"domain"            return yy::parser::make_DOMAIN(yytext, loc);
"problem"           return yy::parser::make_PROBLEM(yytext, loc);

"requirements"      return yy::parser::make_HDDL_REQ_KEYWORD(yytext, loc);
"typing"            return yy::parser::make_HDDL_REQ_PARAM(yytext, loc);
"durative-actions"  return yy::parser::make_HDDL_REQ_PARAM(yytext, loc);
"action-costs"      return yy::parser::make_HDDL_REQ_PARAM(yytext, loc);
"htn"               return yy::parser::make_HDDL_REQ_PARAM(yytext, loc);
"htn-method-prec"   return yy::parser::make_HDDL_REQ_PARAM(yytext, loc);

"types"             return yy::parser::make_HDDL_TYPES_KEYWORD(yytext, loc);
"predicates"        return yy::parser::make_HDDL_PRED_KEYWORD(yytext, loc);
"task"              return yy::parser::make_HDDL_TASK_KEYWORD(yytext, loc);
"ordered-subtasks"  return yy::parser::make_HDDL_ORD_SUBT_KEYWORD(yytext, loc);
"subtasks"          return yy::parser::make_HDDL_SUBT_KEYWORD(yytext, loc);
"method"            return yy::parser::make_HDDL_METHOD_KEYWORD(yytext, loc);
"action"            return yy::parser::make_HDDL_ACTION_KEYWORD(yytext, loc);
"parameters"        return yy::parser::make_HDDL_PARAMS_KEYWORD(yytext, loc);
"duration"          return yy::parser::make_HDDL_OP_DUR_KEYWORD(yytext, loc);
"precondition"      return yy::parser::make_HDDL_OP_PREC_KEYWORD(yytext, loc);
"effect"            return yy::parser::make_HDDL_OP_EFF_KEYWORD(yytext, loc);
"decrease"          return yy::parser::make_HDDL_OP_DEC_KEYWORD(yytext, loc);

"("                 return yy::parser::make_LPAREN(yytext, loc);
")"                 return yy::parser::make_RPAREN(yytext, loc);
":"                 return yy::parser::make_COLON(yytext, loc);
"?"                 return yy::parser::make_QM(yytext, loc);
"-"                 return yy::parser::make_HYPHEN(yytext, loc);
"="                 return yy::parser::make_EQUAL(yytext, loc);
"and"               return yy::parser::make_AND(yytext, loc);
"not"               return yy::parser::make_NOT(yytext, loc);

{strings}           return yy::parser::make_STRING(yytext, loc);

{numbers}           return yy::parser::make_NUMBER(atof(yytext), loc);

{comments}          { /* ignore all comments, do nothing */ }

<<EOF>>             { std::cout << "[hddl parser]: parsing ok!" << std::endl;
                      return yy::parser::make_END(loc); }

.                   { std::cerr << "\033[1;31merror: \033[0m (scanner/lexer) : invalid character -> " << yytext << \
                      " <- \nscanner response: Unable to match char(s) using current regular expressions" << std::endl;
                      hddl_parser.parsing_ok_ = false;
                      return yy::parser::make_OTHER(loc); }

%%   /* ============ Grammar rules end */

void HDDLParser::scan_begin()
{
    yy_flex_debug = false;

    if (domain_.domain_file_path_.empty() || domain_.domain_file_path_ == "-")
    {
        yyin = stdin;
    }
    else if (!(yyin = fopen (domain_.domain_file_path_.c_str (), "r")))
    {
      std::cerr << "cannot open " << domain_.domain_file_path_ << ": " << strerror(errno) << std::endl;
      exit(EXIT_FAILURE);
    }
}

void HDDLParser::scan_end()
{
    fclose(yyin);
}
